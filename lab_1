# fpga_projects
# Lab1_FPGA

# Programm 1

library ieee;
use ieee.std_logic_1164.all;

entity adder1bit is
    port (
        a    : in  std_logic;
        b    : in  std_logic;
        cin  : in  std_logic;
        s    : out std_logic;
        cout : out std_logic
    );
end adder1bit;

architecture behavior of adder1bit is
begin
    s    <= a xor b xor cin;
    cout <= (a and b) or (b and cin) or (a and cin);
end behavior;

# Programm 2

library ieee;
use ieee.std_logic_1164.all;

entity adder8bit is
    port (
        a    : in  std_logic_vector(7 downto 0);
        b    : in  std_logic_vector(7 downto 0);
        cin  : in  std_logic;
        s    : out std_logic_vector(7 downto 0);
        cout : out std_logic
    );
end adder8bit;

architecture structural of adder8bit is
    component adder1bit
        port (
            a    : in  std_logic;
            b    : in  std_logic;
            cin  : in  std_logic;
            s    : out std_logic;
            cout : out std_logic
        );
    end component;

    signal carry : std_logic_vector(8 downto 0);
begin
    carry(0) <= cin;

    gen_adders: for i in 0 to 7 generate
        adder_inst: adder1bit
            port map (
                a    => a(i),
                b    => b(i),
                cin  => carry(i),
                s    => s(i),
                cout => carry(i+1)
            );
    end generate;

    cout <= carry(8);
end structural;

# Programm 3

library ieee;
use ieee.std_logic_1164.all;

entity mux2 is
    port (
        a   : in  std_logic_vector(7 downto 0);
        b   : in  std_logic_vector(7 downto 0);
        sel : in  std_logic;
        y   : out std_logic_vector(7 downto 0)
    );
end mux2;

architecture behavior of mux2 is
begin
    y <= a when sel = '0' else b;
end behavior;

# Programm 4

library ieee;
use ieee.std_logic_1164.all;

entity mux4 is
    port (
        a   : in  std_logic_vector(7 downto 0);
        b   : in  std_logic_vector(7 downto 0);
        c   : in  std_logic_vector(7 downto 0);
        d   : in  std_logic_vector(7 downto 0);
        sel : in  std_logic_vector(1 downto 0);
        y   : out std_logic_vector(7 downto 0)
    );
end mux4;

architecture behavior of mux4 is
begin
    process(a, b, c, d, sel)
    begin
        case sel is
            when "00" => y <= a;
            when "01" => y <= b;
            when "10" => y <= c;
            when "11" => y <= d;
            when others => y <= (others => '0');
        end case;
    end process;
end behavior;

# Programm 5

library ieee;
use ieee.std_logic_1164.all;

package alulib is

    component adder8bit
        port (
            a    : in  std_logic_vector(7 downto 0);
            b    : in  std_logic_vector(7 downto 0);
            cin  : in  std_logic;
            s    : out std_logic_vector(7 downto 0);
            cout : out std_logic
        );
    end component;

    component mux2
        port (
            a   : in  std_logic_vector(7 downto 0);
            b   : in  std_logic_vector(7 downto 0);
            sel : in  std_logic;
            y   : out std_logic_vector(7 downto 0)
        );
    end component;

    component mux4
        port (
            a   : in  std_logic_vector(7 downto 0);
            b   : in  std_logic_vector(7 downto 0);
            c   : in  std_logic_vector(7 downto 0);
            d   : in  std_logic_vector(7 downto 0);
            sel : in  std_logic_vector(1 downto 0);
            y   : out std_logic_vector(7 downto 0)
        );
    end component;

end package alulib;

# Programm 6

library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;
use work.alulib.all;

entity alu is
    generic (n : integer := 8);
    port (
        ac    : in  std_logic_vector(n-1 downto 0);
        db    : in  std_logic_vector(n-1 downto 0);
        alus  : in  std_logic_vector(7 downto 1);
        dout  : out std_logic_vector(n-1 downto 0)
    );
end alu;

architecture arch of alu is
    signal add_res, sub_res : std_logic_vector(n-1 downto 0);
    signal cout             : std_logic;
    signal logic_res        : std_logic_vector(n-1 downto 0);
    signal not_ac           : std_logic_vector(n-1 downto 0);
    signal clac             : std_logic_vector(n-1 downto 0) := (others => '0');
    signal inac             : std_logic_vector(n-1 downto 0);
    signal movr             : std_logic_vector(n-1 downto 0);
    signal ldac             : std_logic_vector(n-1 downto 0);

begin
    -- Αριθμητικές πράξεις
    add_unit: adder8bit port map(ac, db, '0', add_res, cout);
    sub_unit: adder8bit port map(ac, not db, '1', sub_res, cout); -- SUB = A + (~B + 1)

    -- Λογικές πράξεις
    not_ac <= not ac;
    inac   <= ac + 1;
    movr   <= db;
    ldac   <= (others => '0');

    process(ac, db, alus, add_res, sub_res, not_ac, inac)
    begin
        case alus is
            when "1000000" => dout <= ac and db;         -- AND
            when "1100000" => dout <= ac or db;          -- OR
            when "1010000" => dout <= ac xor db;         -- XOR
            when "1110000" => dout <= not_ac;            -- NOT
            when "0000000" => dout <= clac;              -- CLAC (clear ac)
            when "0001001" => dout <= inac;              -- INAC
            when "0000100" => dout <= movr;              -- MOVR
            when "0000101" => dout <= add_res;           -- ADD
            when "0001011" => dout <= sub_res;           -- SUB
            when others    => dout <= (others => '0');   -- Default
        end case;
    end process;

end arch;
